{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"fs\"","webpack:///./app/classes/Record.ts","webpack:///./app/constants.ts","webpack:///./app/index.ts","webpack:///./app/classes/Sort/SortService.ts","webpack:///external \"buffer\"","webpack:///./app/classes/DataService.ts","webpack:///./app/classes/File/File.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","Record","[object Object]","a","x","y","z","this","getValue","Math","pow","getRecordAsArray","getRecordAsInt32Array","Int32Array","from","numberOfRecordsToGenerate","sizeOfRecord","sizeOfInt","numbersInRecord","events","SortService_1","sortService","SortService","generateFileToSort","sort","fs_1","buffer_1","DataService_1","File_1","__awaiter","data","dataService","getDataAsInt32Array","writeFile","Buffer","buffer","err","console","log","divide","firstFile","setNewReadable","secondFile","inputFile","setNewWritable","merge","printFile","finishSeries","fileID","readedRecord","sourceFile","filesArray","fileEnd","currentRecord","readRecord","previousRecord","writeRecord","firstFileRecord","secondFileRecord","event","selectSmallerRecordAndGetNewOne","state","newState","assign","smallerRecord","selectSmallerRecord","currentFirstFileRecord","currentSecondFileRecord","fetchedRecord","firstFileEnds","firstFileSeriesEnds","previousFirstFileRecord","secondFileEnds","secondFileSeriesEnds","previousSecondFileRecord","sortingEvent","fillWithRestOfRecords","id","file","r1","r2","switchingCount","currentFile","undefined","writeSeries","switchFile","Promise","resolve","previous","current","DataService","File","Record_1","constants_1","getDataAsArray","map","record","getFlatData","concat","generateData","push","generateRecord","ceil","random","path","initializeRecord","recordArray","getDataBuffer","readPosition","readInt32LE","readable","createReadStream","start","end","on","read","writable","write","writePosition","createWriteStream"],"mappings":"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","file":"build.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"fs\");","export class Record {\n\n\n    constructor(private readonly a: number,\n                 private readonly c: number,\n                 private readonly x: number,\n                 private readonly y: number,\n                 private readonly z: number) {}\n\n    public getValue = () => 10 * this.a * (Math.pow(this.x, 2) + 3 * Math.pow(this.c, 3) * Math.pow(this.z, 4) - 5 * Math.pow(this.y, 7));\n\n    public getRecordAsArray = () => [\n            this.a,\n            this.c,\n            this.x,\n            this.y,\n            this.z\n        ];\n\n    public getRecordAsInt32Array = () =>\n        Int32Array.from([\n            this.a,\n            this.c,\n            this.x,\n            this.y,\n            this.z\n        ])\n}\n","export const numberOfRecordsToGenerate = 17;\nexport const sizeOfRecord = 20;\nexport const sizeOfInt = 4;\nexport const numbersInRecord = 5;\nexport const enum events {\n    EOF,\n    SWITCH_FILE,\n    SERIES_IN_FIRST_FILE_END,\n    SERIES_IN_SECOND_FILE_END,\n    FIRST_FILE_EOF,\n    SORTING_ENDS\n}\n","import {SortService} from './classes/Sort/SortService';\n\n(async function main() {\n    const sortService = new SortService();\n    await sortService.generateFileToSort();\n    await sortService.sort();\n})();\n","//external\nimport {writeFile} from 'fs';\nimport {Buffer} from 'buffer';\n//internal\nimport {DataService} from '../DataService';\nimport {File} from '../File/File';\nimport {Record} from '../Record';\nimport {events} from '../../constants';\nimport {SortingEvent} from './SortingEvent';\n\n\nexport class SortService {\n    private dataService: DataService;\n    private inputFile: File;\n    private firstFile: File;\n    private secondFile: File;\n    private currentFile: File;\n    private previousRecord: Record;\n    private currentRecord: Record;\n    private filesArray: File[];\n\n    constructor() {\n        this.dataService = new DataService(undefined);\n        this.inputFile = new File('./unsortedInput', 0);\n        this.firstFile = new File('./firstFile', 1);\n        this.currentFile = this.firstFile;\n        this.secondFile = new File('./secondFile', 2);\n        this.filesArray = [\n            this.inputFile,\n            this.firstFile,\n            this.secondFile\n        ];\n    };\n\n    public generateFileToSort = async () => {\n        const data: Int32Array = this.dataService.getDataAsInt32Array();\n        writeFile('./unsortedInput', Buffer.from(data.buffer), (err) => {\n            if (err) throw err;\n            console.log('The \"data to append\" was appended to file!');\n        });\n    };\n\n    public sort = async() => {\n        while(await this.divide() !== events.SORTING_ENDS){\n            this.firstFile.setNewReadable();\n            this.secondFile.setNewReadable();\n            this.inputFile.setNewWritable();\n            await this.merge();\n            this.inputFile.setNewReadable();\n            this.firstFile.setNewWritable();\n            this.secondFile.setNewWritable();\n\n            await this.inputFile.printFile();\n        }\n        await this.inputFile.printFile();\n    };\n\n    private finishSeries = async (fileID: number, readedRecord: Record) => {\n        const sourceFile: File = this.filesArray[fileID];\n        let currentRecord: Record = await sourceFile.readRecord();\n        let previousRecord: Record = readedRecord;\n        let fileEnd: events;\n\n        this.inputFile.writeRecord(readedRecord);\n        if(!currentRecord){//EOF\n            return {\n                firstFileRecord: null,\n                secondFileRecord: null,\n                event: events.EOF,\n            }\n        }\n        while(previousRecord.getValue() < currentRecord.getValue()){\n            this.inputFile.writeRecord(currentRecord);\n            previousRecord = currentRecord;\n            currentRecord = await sourceFile.readRecord();\n            if(currentRecord === null){\n                fileEnd = events.EOF\n            }\n        }\n\n        return {\n            firstFileRecord: fileID === 1 && currentRecord,\n            secondFileRecord: fileID === 2 && currentRecord,\n            event: fileEnd === events.EOF ? events.EOF : (fileID === 1 ? events.SERIES_IN_FIRST_FILE_END : events.SERIES_IN_SECOND_FILE_END)\n        }\n    };\n\n    private selectSmallerRecordAndGetNewOne = async (state) => {\n        const newState = { ...state };\n        const smallerRecord = this.selectSmallerRecord(newState.currentFirstFileRecord, newState.currentSecondFileRecord);\n\n        if(smallerRecord === newState.currentFirstFileRecord){\n            const fetchedRecord = await this.firstFile.readRecord();//unhandled EOF\n            if(fetchedRecord === null){\n                return {\n                    ...newState,\n                    smallerRecord,\n                    firstFileEnds: true\n                }\n            }\n            if(fetchedRecord.getValue() < newState.currentFirstFileRecord.getValue()){//series in first file ends\n                newState.firstFileSeriesEnds = true;\n            }\n            newState.previousFirstFileRecord = newState.currentFirstFileRecord;\n            newState.currentFirstFileRecord = fetchedRecord;\n        }else if(smallerRecord === newState.currentSecondFileRecord){\n            const fetchedRecord = await this.secondFile.readRecord();\n            if(fetchedRecord === null){\n                return {\n                    ...newState,\n                    smallerRecord,\n                    secondFileEnds: true\n                }\n            }\n\n            if(fetchedRecord.getValue() < newState.currentSecondFileRecord.getValue()){//series in first file ends\n                newState.secondFileSeriesEnds = true;\n            }\n            newState.previousSecondFileRecord = newState.currentSecondFileRecord;\n            newState.currentSecondFileRecord = fetchedRecord;\n        }\n\n        return {\n            ...newState,\n            smallerRecord\n        };\n    };\n\n    private merge = async () => {\n        const state = {\n            firstFileSeriesEnds: false,\n            secondFileSeriesEnds: false,\n            firstFileEnds: false,\n            secondFileEnds: false,\n            previousFirstFileRecord: null,\n            previousSecondFileRecord: null,\n            currentFirstFileRecord: await this.firstFile.readRecord(),\n            currentSecondFileRecord: await this.secondFile.readRecord(),\n            smallerRecord: null\n        };\n        let sortingEvent: SortingEvent;\n\n        while(true){\n            Object.assign(state, await this.selectSmallerRecordAndGetNewOne({ ...state }));//unhandled EOF\n            this.inputFile.writeRecord(state.smallerRecord);\n            if(state.firstFileEnds){\n                //fill With rest of SecondFile\n                this.inputFile.writeRecord(state.currentSecondFileRecord);\n                this.fillWithRestOfRecords(this.secondFile);\n                break;//merge ends\n            }else if(state.secondFileEnds){\n                //fill With rest of FirstFile\n                this.inputFile.writeRecord(state.currentFirstFileRecord);\n                this.fillWithRestOfRecords(this.firstFile);\n                break;//merge ends\n            }else if(state.firstFileSeriesEnds){\n                sortingEvent = await this.finishSeries(this.secondFile.id, state.currentSecondFileRecord);// if !EOF then sortingEvent got current record from secondFile\n                if(sortingEvent.event === events.EOF){\n                    if(state.currentFirstFileRecord){\n                        this.inputFile.writeRecord(state.currentFirstFileRecord);\n                    }\n                    await this.fillWithRestOfRecords(this.firstFile);\n                    break;//merge ends\n                }\n                state.currentSecondFileRecord = sortingEvent.secondFileRecord;\n                //state.currentFirstFileRecord = await this.firstFile.readRecord();\n            }else if(state.secondFileSeriesEnds){\n                sortingEvent = await this.finishSeries(this.firstFile.id, state.currentFirstFileRecord);// if !EOF then sortingEvent got current record from firstFile\n                if(sortingEvent.event === events.EOF){\n                    if(state.currentSecondFileRecord){\n                        this.inputFile.writeRecord(state.currentSecondFileRecord);\n                    }\n                    await this.fillWithRestOfRecords(this.secondFile);\n                    break;//merge ends\n                }\n                state.currentFirstFileRecord = sortingEvent.firstFileRecord;\n                //state.currentSecondFileRecord = await this.secondFile.readRecord()\n            }\n            state.secondFileSeriesEnds = false;\n            state.firstFileSeriesEnds = false;\n        }\n    };\n\n    private fillWithRestOfRecords = async (file: File) => {\n        let currentRecord = await file.readRecord();\n        while(currentRecord){\n            this.inputFile.writeRecord(currentRecord);\n            currentRecord = await file.readRecord();\n        }\n    };\n\n    private selectSmallerRecord = (r1: Record, r2: Record): Record => r1.getValue() < r2.getValue() ? r1 : r2;\n\n    private divide = async () => {\n        let switchingCount = 0;\n        this.currentFile = this.firstFile;\n        this.currentRecord = undefined;\n\n        while(await this.writeSeries() !== events.EOF){\n            this.switchFile();\n            switchingCount++;\n        }\n        if(switchingCount === 0){//?\n            return events.SORTING_ENDS;\n        }\n    };\n\n    private writeSeries = async (): Promise<events> => (\n        new Promise<events>(async resolve => {\n            let previous: Record = this.currentRecord || await this.inputFile.readRecord();\n            let current: Record = await this.inputFile.readRecord();\n\n            this.currentFile.writeRecord(previous);\n            if(current === null){\n                resolve(events.EOF);\n            }\n            while(previous.getValue() < current.getValue()){\n                this.currentFile.writeRecord(current);\n                previous = current;\n                current = await this.inputFile.readRecord();\n                if(current === null){\n                    resolve(events.EOF);\n                }\n            }\n            this.currentRecord = current;\n            resolve(events.SWITCH_FILE);\n        })\n    );\n\n    private switchFile = (): void => {\n        if(this.currentFile.id === this.firstFile.id){\n            this.currentFile = this.secondFile;\n        }else if(this.currentFile.id === this.secondFile.id){\n            this.currentFile = this.firstFile\n        }\n    }\n}\n","module.exports = require(\"buffer\");","import { Record } from './Record';\nimport { numberOfRecordsToGenerate } from '../constants';\n\nexport class DataService {\n\n    public data: Record[];\n\n    constructor(data: Record[]) {\n        if(!data){\n            this.generateData();\n        }else{\n            this.data = data;\n        }\n\n    }\n\n    private getDataAsArray = (): Array<Array<number>>  => this.data.map((record: Record) => record.getRecordAsArray());\n\n    public getFlatData = (): Array<number> => [].concat(...this.getDataAsArray());\n\n    public getDataAsInt32Array = (): Int32Array => Int32Array.from(this.getFlatData());\n\n    public generateData = () => {\n        const data = [];\n        for(let i = 0; i < numberOfRecordsToGenerate; i++) {\n            data.push(this.generateRecord());\n        }\n        this.data = data;\n    };\n\n    private generateRecord = () => {\n      return new Record(\n          Math.ceil(Math.random() * 10),\n          Math.ceil(Math.random() * 10),\n          Math.ceil(Math.random() * 10),\n          Math.ceil(Math.random() * 10),\n          Math.ceil(Math.random() * 10)\n      );\n    };\n}\n","//external\nimport { createReadStream, createWriteStream, WriteStream } from 'fs';\n//internal\nimport { sizeOfInt, sizeOfRecord, numbersInRecord } from '../../constants'\nimport { Record } from '../Record';\n\nexport class File {\n    private readPosition: number;\n    private writePosition: number;\n    private writable: WriteStream;\n\n    constructor(readonly path: string, readonly id: number){\n        this.readPosition = 0;\n        this.writePosition = 0;\n        this.writable = createWriteStream(this.path);\n    }\n\n    private initializeRecord = (recordArray: Int32Array) => {\n        return new Record(\n            recordArray[0],\n            recordArray[1],\n            recordArray[2],\n            recordArray[3],\n            recordArray[4]\n        )\n    };\n\n    public printFile = async() => {\n        let record: Record;\n        this.setNewReadable();\n        console.log('printFILE');\n        while(record = await this.readRecord()){\n            console.log(record.getValue());\n        }\n        console.log('printEND');\n    };\n\n    public readRecord = async () => {\n        const recordArray: Int32Array = new Int32Array(numbersInRecord);\n        const buffer: Buffer = await this.getDataBuffer();\n\n        if(buffer === null){\n            this.readPosition = 0;\n            return null;\n        }\n        for(let i = 0; i < numbersInRecord; i++) {\n            recordArray[i] = buffer.readInt32LE(i * sizeOfInt);\n            if(recordArray[i] === null){\n                this.readPosition = 0;\n                return null;\n            }\n        }\n\n        return this.initializeRecord(recordArray);\n    };\n\n    private getDataBuffer = ():Promise<Buffer> => (\n        new Promise((resolve) => {\n                const readable = createReadStream(this.path, {start: this.readPosition, end: this.readPosition + sizeOfRecord});\n\n                this.readPosition += sizeOfRecord;\n                readable.on('readable', () => {\n                    resolve(readable.read(sizeOfRecord));\n                });\n            }\n        )\n    );\n\n    public writeRecord = (record: Record) => {\n        const buffer = Buffer.from(record.getRecordAsInt32Array().buffer);\n        this.writable.write(buffer);\n        this.writePosition += sizeOfRecord;\n    };\n\n    public setNewWritable = (): void => {\n        this.writable = createWriteStream(this.path);\n    };\n\n    public setNewReadable = (): void => {\n        this.readPosition = 0;\n    }\n}\n"],"sourceRoot":""}